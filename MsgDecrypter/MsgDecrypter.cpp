//
// Created by 23945 on 2023/8/1.
//

#include <fmt/format.h>
#include <vector>
#include <sstream>
#include <map>
#include <functional>
#include "CodeCvt.h"
#include "Buffer.h"

uint8_t data[] = {0x4d, 0x53, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdd, 0x67, 0xc6, 0x64, 0x81, 0xd3, 0x87, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x86,
                  0x02, 0x04, 0x00, 0x8b, 0x5b, 0x53, 0x4f, 0x12, 0x01, 0x00, 0x0f, 0x01, 0x54, 0x44, 0x01, 0x01, 0x04, 0x00, 0x06, 0x10, 0x00, 0x8b, 0xef,
                  0x98, 0xef, 0xa2, 0xef, 0x9c, 0xef, 0x88, 0xef, 0xbc, 0xef, 0x8a, 0xef, 0x9e, 0xef, 0x04, 0x00, 0x00, 0x00, 0x01, 0x83, 0x00, 0x00, 0x06,
                  0x14, 0x00, 0x8f, 0xeb, 0x9c, 0xeb, 0xa9, 0xeb, 0x8e, 0xeb, 0x8c, 0xeb, 0x82, 0xeb, 0x85, 0xeb, 0xb8, 0xeb, 0x8e, 0xeb, 0x9a, 0xeb, 0x04,
                  0x00, 0x00, 0x00, 0x01, 0x83, 0x00, 0x00, 0x06, 0x10, 0x00, 0x8b, 0xef, 0x98, 0xef, 0xaa, 0xef, 0x81, 0xef, 0x8b, 0xef, 0xbc, 0xef, 0x8a,
                  0xef, 0x9e, 0xef, 0x04, 0x00, 0x00, 0x00, 0x01, 0x83, 0x00, 0x00, 0x0c, 0x14, 0x00, 0x8a, 0xeb, 0x99, 0xeb, 0x99, 0xeb, 0xbb, 0xeb, 0x8a,
                  0xeb, 0x88, 0xeb, 0x80, 0xeb, 0x8e, 0xeb, 0x9f, 0xeb, 0x98, 0xeb, 0x99, 0x00, 0x00, 0x00, 0x54, 0x41, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
                  0x0b, 0x8c, 0x00, 0x00, 0x00, 0x54, 0x44, 0x01, 0x01, 0x04, 0x00, 0x06, 0x1a, 0x00, 0x81, 0xe5, 0x92, 0xe5, 0xb5, 0xe5, 0x84, 0xe5, 0x86,
                  0xe5, 0x8e, 0xe5, 0x80, 0xe5, 0x91, 0xe5, 0xa6, 0xe5, 0x8a, 0xe5, 0x90, 0xe5, 0x8b, 0xe5, 0x91, 0xe5, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
                  0x00, 0x00, 0x06, 0x10, 0x00, 0x8b, 0xef, 0x98, 0xef, 0xa2, 0xef, 0x9c, 0xef, 0x88, 0xef, 0xbc, 0xef, 0x8a, 0xef, 0x9e, 0xef, 0x04, 0x00,
                  0x00, 0x00, 0x01, 0x83, 0x00, 0x00, 0x06, 0x16, 0x00, 0x8d, 0xe9, 0x9e, 0xe9, 0xb9, 0xe9, 0x88, 0xe9, 0x8a, 0xe9, 0x82, 0xe9, 0x8c, 0xe9,
                  0x9d, 0xe9, 0xba, 0xe9, 0x8c, 0xe9, 0x98, 0xe9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x1a, 0x00, 0x81, 0xe5, 0x92, 0xe5,
                  0xb5, 0xe5, 0x84, 0xe5, 0x86, 0xe5, 0x8e, 0xe5, 0x80, 0xe5, 0x91, 0xe5, 0xac, 0xe5, 0x8b, 0xe5, 0x81, 0xe5, 0x80, 0xe5, 0x9d, 0xe5, 0x04,
                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1c, 0x00, 0x01, 0x01, 0x00, 0xff, 0x02, 0x15, 0x00, 0x08, 0xa9, 0x02, 0x12, 0x07, 0x2f,
                  0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x1a, 0x07, 0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x02, 0x1c, 0x00, 0x01, 0x01, 0x00, 0xff, 0x02,
                  0x15, 0x00, 0x08, 0xa9, 0x02, 0x12, 0x07, 0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x1a, 0x07, 0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2,
                  0x02, 0x1c, 0x00, 0x01, 0x01, 0x00, 0xff, 0x02, 0x15, 0x00, 0x08, 0xa9, 0x02, 0x12, 0x07, 0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x1a,
                  0x07, 0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x02, 0x1c, 0x00, 0x01, 0x01, 0x00, 0xff, 0x02, 0x15, 0x00, 0x08, 0xa9, 0x02, 0x12, 0x07,
                  0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x1a, 0x07, 0x2f, 0xe6, 0x8b, 0x9c, 0xe8, 0xb0, 0xa2, 0x12, 0x13, 0x00, 0x02, 0x10, 0x00, 0xd8,
                  0x9a, 0x09, 0x4e, 0xba, 0x4e, 0x08, 0xff, 0x07, 0x59, 0xce, 0x80, 0x48, 0x72, 0x09, 0xff, 0x19, 0x64, 0x00, 0x01, 0x61, 0x00, 0xaa, 0x02,
                  0x5e, 0x88, 0x01, 0x00, 0x9a, 0x01, 0x58, 0x20, 0xcb, 0x50, 0x78, 0x80, 0x80, 0x04, 0xc8, 0x01, 0x00, 0xf0, 0x01, 0x00, 0xf8, 0x01, 0x00,
                  0x90, 0x02, 0x00, 0xc8, 0x02, 0x00, 0x98, 0x03, 0x00, 0xa0, 0x03, 0x00, 0xb0, 0x03, 0x00, 0xc0, 0x03, 0x00, 0xd0, 0x03, 0x00, 0xb8, 0x04,
                  0x00, 0xc0, 0x04, 0x00, 0xca, 0x04, 0x02, 0x10, 0x00, 0x88, 0x05, 0x00, 0xd2, 0x05, 0x22, 0x1a, 0x20, 0x08, 0x91, 0xf0, 0xfa, 0xe6, 0x03,
                  0x12, 0x18, 0x75, 0x5f, 0x49, 0x52, 0x2d, 0x70, 0x39, 0x49, 0x4b, 0x61, 0x68, 0x4a, 0x33, 0x4a, 0x67, 0x64, 0x33, 0x45, 0x53, 0x64, 0x7a,
                  0x36, 0x75, 0x67, 0x0e, 0x00, 0x00};


struct MsgPacketHeader {
    std::uint8_t  type[8]{};                  // 8 字节标识
    std::uint32_t timeStamp{};                // 10 位长时间戳
    std::uint32_t rand{};
    std::uint32_t color{};
    std::uint8_t  fontSize{};
    std::uint8_t  fontStyle{};
    std::uint8_t  charSet{};
    std::uint8_t  fontFamily{};

    // vvv offset 0x18
    std::uint16_t        fontNameLength{};
    std::vector<wchar_t> fontName;
    std::uint8_t         unknow[2]{};
};

struct MsgPacketContent {
    std::uint8_t              type{};
    std::uint16_t             len{};
    std::vector<std::uint8_t> data;

    MsgPacketContent(std::uint8_t *DataStart, std::size_t Count) {
        Buffer buffer{DataStart, Count};
        type = buffer.read<uint8_t>();
        len  = buffer.read<uint16_t>();
        data.resize(len, '\0');
        buffer.read(data.data(), len);
    }
};

std::string MsgPacketDecodeText() {


    return {};
}

std::string MsgPacketDecodeNickName(std::vector<uint8_t> &Data) {
    MsgPacketContent msgPacketContent{Data.data(), Data.size()};

    std::string nickName;
    switch (msgPacketContent.type) {
        case 1:
        case 2:
            std::wstring ws{(wchar_t *) msgPacketContent.data.data(), msgPacketContent.data.size() / 2};
            nickName = CodeCvt::WstrToStr(ws, CP_ACP);
            break;
    }
    return nickName;
}

enum MsgPacket_Type {
    MsgText         = 1,
    MsgFace         = 2,
    MsgGroupImage   = 3,
    MsgPrivateImage = 6,
    MsgVoice        = 7,
    MsgNickName     = 18,
    MsgVideo        = 26
};

struct MsgPacketParser {
    std::vector<std::pair<std::uint8_t, std::string>> decodeContent;

    MsgPacketParser(uint8_t *DataPtr, size_t Count) {
        try {
            Buffer          bufferReader{DataPtr, Count};
            /**
             *  Header 解析
             */
            MsgPacketHeader msgPacket{};
            bufferReader.read<8>(msgPacket.type);
            msgPacket.timeStamp      = bufferReader.read<uint32_t>();
            msgPacket.rand           = bufferReader.read<uint32_t>();
            msgPacket.color          = bufferReader.read<uint32_t>();
            msgPacket.fontSize       = bufferReader.read<uint8_t>();
            msgPacket.fontStyle      = bufferReader.read<uint8_t>();
            msgPacket.charSet        = bufferReader.read<uint8_t>();
            msgPacket.fontFamily     = bufferReader.read<uint8_t>();
            msgPacket.fontNameLength = bufferReader.read<uint16_t>();
            msgPacket.fontName.resize(msgPacket.fontNameLength / 2 + 1, '\0');
            bufferReader.read((uint8_t *) msgPacket.fontName.data(), msgPacket.fontNameLength);
            bufferReader.skip(2);

            /**
             *  Content 解析
             */
            while (!bufferReader.eof()) {
                MsgPacketContent msgPacketContent{bufferReader.getCurrentElement(), bufferReader.getMaxPos() - bufferReader.getCurrnetPos()};
                // skip type + len + data
                bufferReader.skip(1 + 2 + msgPacketContent.len);

                switch (msgPacketContent.type) {
                    case MsgPacket_Type::MsgNickName:
                        decodeContent.emplace_back(MsgPacket_Type::MsgNickName, MsgPacketDecodeNickName(msgPacketContent.data));
                        break;
                }
                fmt::println("type: {}\nlen: {}", msgPacketContent.type, msgPacketContent.len);

            }
        } catch (std::exception &exception) {
            fmt::println("raise exception: {}", exception.what());
        }

        fmt::println("\n");
        for (auto & i : decodeContent) {
            fmt::println("type: {}\ndecode text: {}", i.first, i.second);
        }
    }
};


int main() {
    setbuf(stdout, nullptr);


    MsgPacketParser msgPacketParser{data, sizeof(data) / sizeof(data[0])};
//    fmt::println("{}", (char *) data);

}